/**
  \brief Test para la clase mp_4000_controller
  \author Antonio Garcia
  \date 18/12/2020
*/

#include "gtest/gtest.h"

#include "mp_4000_controller.h"
#include "uC_interface.h"

uC_PseudoDelayGenerator delayGenerator;
uC_PseudoSerialController serialController;
uC_Pseudo_wdt_interface watchdog;
/**
  \class Tester_Mp_4000_Controller
*/
class Tester_Mp_4000_Controller : public Mp_4000_Controller {
    public:
    Tester_Mp_4000_Controller( uC_DelayGenerator& delayGenerator_0, uC_SerialController& debugPrinter_0, uC_wdt_interface& watchdog_0, uint16_t timeout_mp_4000 ) :
        Mp_4000_Controller( delayGenerator_0, debugPrinter_0, watchdog_0, timeout_mp_4000 ) {
        };

    void tester_parse_reply_byte( uint8_t byte ) {
        parse_reply_byte( byte );
    }

    Parse_reply_state_t get_state() const {
        return state;
    }

    uint8_t get_reply_vector_lenght() const {
        return reply_vector_lenght;
    }
};

/**
    Fixture class para los diferentes test
*/
class Fixture_Mp_4000_Controller : public ::testing::Test {
 protected:
    void SetUp() override {
        mp_4000 = new Tester_Mp_4000_Controller( delayGenerator, serialController, watchdog, 1000 );
    }

    void TearDown() override {
    }

    Tester_Mp_4000_Controller* mp_4000;
};

/**
  \test Test para la m치quina de estados
*/
TEST_F( Fixture_Mp_4000_Controller, check_state_machine ) {
    uint8_t reply_vector_lenght = mp_4000->get_reply_vector_lenght();

    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
    mp_4000->tester_parse_reply_byte( 0x01 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
    mp_4000->tester_parse_reply_byte( 0x1B );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::wait_start_reply );
    mp_4000->tester_parse_reply_byte( 0x56 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
    mp_4000->tester_parse_reply_byte( 0x1B );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::wait_start_reply );
    mp_4000->tester_parse_reply_byte( 0x02 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::wait_reply_end );
    for ( uint8_t i = 0; i < reply_vector_lenght - 2; i++ ) {
        mp_4000->tester_parse_reply_byte( 0x00 );
    }
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::wait_reply_end );
    mp_4000->tester_parse_reply_byte( 0x00 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
}

/**
  \test Test para la m치quina de estados
*/
TEST_F( Fixture_Mp_4000_Controller, reply_sensor_read_out_and_control_frame_resp ) {
    int16_t supply1_air_temperature = 0, return_air_temperature = 0, temperature_set_point = 0;
    uint8_t power_state = 0;

    uint8_t reply_sensor_read_out [] = {0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x00,0xED,0x00,0xFE,0x7F,0xD3,0x00,0xD6,0x00,
    0xC8,0x00,0xD1,0x00,0xFE,0x7F,0xBB,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x55,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x84,0x01,
    0x32,0x00,0x37,0x00,0x37,0x00,0x37,0x00,0xFE,0x7F,0xFE,0x7F,0x3C,0x00,0x00,0x00,0x86,0x01,0x59,0x6F,0x00,0x00,0x11,0x00,0x00,0x00,
    0x2F,0x15,0x03,0x00,0xFE,0x7F,0xFE,0x7F,0xED,0x00,0xD3,0x00,0x5B,0x28,0x1B,0x04};

    uint8_t reply_control_frame_resp[] = {0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x01,0x00,0x00,0xB8,0x0B,0x9C,0xFF,0x01,0x01,
    0x00,0xFE,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x08,0x07,0x06,0x00,0x00,0x58,0x00,0x1B,0x04};

    for ( uint8_t i = 0; i < sizeof( reply_sensor_read_out ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_sensor_read_out[i] );
    }

    for ( uint8_t i = 0; i < sizeof( reply_control_frame_resp ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_control_frame_resp[i] );
    }

    mp_4000->get_supply1_air_temperature( supply1_air_temperature );
    mp_4000->get_return_air_temperature( return_air_temperature );
    mp_4000->get_temperature_set_point( temperature_set_point );
    mp_4000->get_power_state( power_state );

    EXPECT_EQ( supply1_air_temperature, 237 );
    EXPECT_EQ( return_air_temperature, 211 );
    EXPECT_EQ( temperature_set_point, 3000 );
    EXPECT_EQ( power_state, 1 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
}

/**
  \test Test para la m치quina de estados
*/
TEST_F( Fixture_Mp_4000_Controller, reply_with_noise_at_the_beginning_and_at_the_end ) {
    int16_t supply1_air_temperature = 0, return_air_temperature = 0, temperature_set_point = 0;
    uint8_t power_state = 0;

    uint8_t reply_sensor_read_out [] = {0xFF,0xFF,0xFF,0xFF,0xFF,0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x00,0xED,0x00,0xFE,0x7F,0xD3,0x00,
    0xD6,0x00,0xC8,0x00,0xD1,0x00,0xFE,0x7F,0xBB,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x55,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,
    0x84,0x01,0x32,0x00,0x37,0x00,0x37,0x00,0x37,0x00,0xFE,0x7F,0xFE,0x7F,0x3C,0x00,0x00,0x00,0x86,0x01,0x59,0x6F,0x00,0x00,0x11,0x00,
    0x00,0x00,0x2F,0x15,0x03,0x00,0xFE,0x7F,0xFE,0x7F,0xED,0x00,0xD3,0x00,0x5B,0x28,0x1B,0x04,0xFF,0xFF,0xFF,0xFF,0xFF};

    uint8_t reply_control_frame_resp[] = {0xFF,0xFF,0xFF,0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x01,0x00,0x00,0xB8,0x0B,0x9C,0xFF,0x01,0x01,
    0x00,0xFE,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x08,0x07,0x06,0x00,0x00,0x58,0x00,0x1B,0x04,0xFF,0xFF,0xFF};

    for ( uint8_t i = 0; i < sizeof( reply_sensor_read_out ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_sensor_read_out[i] );
    }

    for ( uint8_t i = 0; i < sizeof( reply_control_frame_resp ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_control_frame_resp[i] );
    }

    mp_4000->get_supply1_air_temperature( supply1_air_temperature );
    mp_4000->get_return_air_temperature( return_air_temperature );
    mp_4000->get_temperature_set_point( temperature_set_point );
    mp_4000->get_power_state( power_state );

    EXPECT_EQ( supply1_air_temperature, 237 );
    EXPECT_EQ( return_air_temperature, 211 );
    EXPECT_EQ( temperature_set_point, 3000 );
    EXPECT_EQ( power_state, 1 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
}

/**
  \test Test para la m치quina de estados
*/
TEST_F( Fixture_Mp_4000_Controller, reply_with_byte_stuffed ) {
    int16_t supply1_air_temperature = 0, return_air_temperature = 0, temperature_set_point = 0;
    uint8_t power_state = 0;

    uint8_t reply_sensor_read_out [] = {0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x00,0xE5,0xFF,0xFE,0x7F,0x1B,0x1B,0x00,0xFE,0xFF,0x91,0x00,
    0xD5,0x00,0xFE,0x7F,0x8C,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xF8,0x7F,
    0x5E,0x01,0x5E,0x01,0x5E,0x01,0xFE,0x7F,0xFE,0x7F,0x00,0x00,0x00,0x00,0x7E,0x01,0x2A,0x32,0x00,0x00,0x09,0x15,0x00,0x00,0x66,0xC7,
    0x0F,0x00,0xFE,0x7F,0xFE,0x7F,0xE5,0xFF,0x1B,0x1B,0x00,0x4E,0x2F,0x1B,0x04};

    uint8_t reply_control_frame_resp[] = {0xFF,0xFF,0xFF,0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x01,0x00,0x00,0xB8,0x0B,0x9C,0xFF,0x01,0x01,
    0x00,0xFE,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x08,0x07,0x06,0x00,0x00,0x58,0x00,0x1B,0x04,0xFF,0xFF,0xFF};

    for ( uint8_t i = 0; i < sizeof( reply_sensor_read_out ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_sensor_read_out[i] );
    }

    for ( uint8_t i = 0; i < sizeof( reply_control_frame_resp ); i++ ) {
        mp_4000->tester_parse_reply_byte( reply_control_frame_resp[i] );
    }

    mp_4000->get_supply1_air_temperature( supply1_air_temperature );
    mp_4000->get_return_air_temperature( return_air_temperature );
    mp_4000->get_temperature_set_point( temperature_set_point );
    mp_4000->get_power_state( power_state );

    EXPECT_EQ( supply1_air_temperature, -27 );
    EXPECT_EQ( return_air_temperature, 27 );
    EXPECT_EQ( temperature_set_point, 3000 );
    EXPECT_EQ( power_state, 1 );
    EXPECT_EQ( mp_4000->get_state(), Mp_4000_Controller::idle );
}

//To Do: crear mock hardware serial y testear los metodos "set_sensor_read_out" y "set_control_read_out"
// /**
//   \test Test para envio de comando
// */
// TEST_F( Fixture_Mp_4000_Controller, If_set_sensor_read_out_is_called_Then_the_command_is_sent_correctly ) {
//     uint8_t reply_sensor_read_out [] = {0x1B,0x02,0x04,0x00,0x00,0x82,0xA7,0x00,0xED,0x00,0xFE,0x7F,0xD3,0x00,0xD6,0x00,
//     0xC8,0x00,0xD1,0x00,0xFE,0x7F,0xBB,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x55,0x00,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0x84,0x01,
//     0x32,0x00,0x37,0x00,0x37,0x00,0x37,0x00,0xFE,0x7F,0xFE,0x7F,0x3C,0x00,0x00,0x00,0x86,0x01,0x59,0x6F,0x00,0x00,0x11,0x00,0x00,0x00,
//     0x2F,0x15,0x03,0x00,0xFE,0x7F,0xFE,0x7F,0xED,0x00,0xD3,0x00,0x5B,0x28,0x1B,0x04};

//     EXPECT_CALL( mock_mp_4000_serial, write(Matcher<const uint8_t *>(_), Matcher<size_t>(_)))
//         .WillOnce( Return( 0 ) );

//     for (uint8_t i = 0; i < sizeof( reply_sensor_read_out ); i++) {
//         EXPECT_CALL( mock_mp_4000_serial, available() ).WillOnce( Return( 1 ) );
//         EXPECT_CALL( mock_mp_4000_serial, read() ).WillOnce( Return( reply_sensor_read_out[ i ] ) );
//     }

//     EXPECT_CALL( *delay_mock, _delay_ms( 1 ) ).Times( Exactly( 1 ) );
    
//     EXPECT_EQ( mp_4000->set_sensor_read_out(), true );
// }

